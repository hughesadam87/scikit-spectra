<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pandas.core.series &mdash; scikit-spectra 0.3.1-2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.1-2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="scikit-spectra 0.3.1-2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../../../index.html">scikit-spectra 0.3.1-2 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>


<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../../../index.html"><img src="../../../_static/new_logo.png" border="100" alt="sampledoc"/></a>
</div>


    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pandas.core.series</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data structure for 1-dimensional cross-sectional and time series data</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="c"># pylint: disable=E1101,E1103</span>
<span class="c"># pylint: disable=W0703,W0622,W0613,W0201</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">nan</span><span class="p">,</span> <span class="n">ndarray</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">pandas.core.common</span> <span class="kn">import</span> <span class="p">(</span><span class="n">isnull</span><span class="p">,</span> <span class="n">notnull</span><span class="p">,</span> <span class="n">_is_bool_indexer</span><span class="p">,</span>
                                <span class="n">_default_index</span><span class="p">,</span> <span class="n">_maybe_upcast</span><span class="p">,</span>
                                <span class="n">_asarray_tuplesafe</span><span class="p">,</span> <span class="n">_infer_dtype_from_scalar</span><span class="p">,</span>
                                <span class="n">is_list_like</span><span class="p">,</span> <span class="n">_values_from_object</span><span class="p">,</span>
                                <span class="n">_possibly_cast_to_datetime</span><span class="p">,</span> <span class="n">_possibly_castable</span><span class="p">,</span>
                                <span class="n">_possibly_convert_platform</span><span class="p">,</span> <span class="n">_try_sort</span><span class="p">,</span>
                                <span class="n">ABCSparseArray</span><span class="p">,</span> <span class="n">_maybe_match_name</span><span class="p">,</span>
                                <span class="n">_ensure_object</span><span class="p">,</span> <span class="n">SettingWithCopyError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">InvalidIndexError</span><span class="p">,</span>
                               <span class="n">_ensure_index</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="kn">import</span> <span class="n">_check_bool_indexer</span><span class="p">,</span> <span class="n">_maybe_convert_indices</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">generic</span><span class="p">,</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="n">SingleBlockManager</span>
<span class="kn">from</span> <span class="nn">pandas.core.categorical</span> <span class="kn">import</span> <span class="n">Categorical</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.period</span> <span class="kn">import</span> <span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">Period</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">pandas.util.terminal</span> <span class="kn">import</span> <span class="n">get_terminal_size</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="kn">import</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">pandas.core.array</span> <span class="kn">as</span> <span class="nn">pa</span>
<span class="kn">import</span> <span class="nn">pandas.core.ops</span> <span class="kn">as</span> <span class="nn">ops</span>
<span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="n">select_n</span>

<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="kn">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.datetools</span> <span class="kn">as</span> <span class="nn">datetools</span>
<span class="kn">import</span> <span class="nn">pandas.core.format</span> <span class="kn">as</span> <span class="nn">fmt</span>
<span class="kn">import</span> <span class="nn">pandas.core.nanops</span> <span class="kn">as</span> <span class="nn">nanops</span>
<span class="kn">from</span> <span class="nn">pandas.util.decorators</span> <span class="kn">import</span> <span class="n">Appender</span><span class="p">,</span> <span class="n">cache_readonly</span>

<span class="kn">import</span> <span class="nn">pandas.lib</span> <span class="kn">as</span> <span class="nn">lib</span>
<span class="kn">import</span> <span class="nn">pandas.tslib</span> <span class="kn">as</span> <span class="nn">tslib</span>
<span class="kn">import</span> <span class="nn">pandas.index</span> <span class="kn">as</span> <span class="nn">_index</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">percentile</span> <span class="k">as</span> <span class="n">_quantile</span>
<span class="kn">from</span> <span class="nn">pandas.core.config</span> <span class="kn">import</span> <span class="n">get_option</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Series&#39;</span><span class="p">]</span>

<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">,</span>
    <span class="n">klass</span><span class="o">=</span><span class="s">&#39;Series&#39;</span><span class="p">,</span>
    <span class="n">axes_single_arg</span><span class="o">=</span><span class="s">&quot;{0,&#39;index&#39;}&quot;</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_coerce_method</span><span class="p">(</span><span class="n">converter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; install the scalar coercion methods &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s">&quot;cannot convert the series to {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">converter</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_unbox</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Series</span><span class="p">))</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># return NumPy type</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
            <span class="k">return</span> <span class="n">result</span>
    <span class="n">f</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="c">#----------------------------------------------------------------------</span>
<span class="c"># Series class</span>


<span class="k">class</span> <span class="nc">Series</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">IndexOpsMixin</span><span class="p">,</span> <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional ndarray with axis labels (including time series).</span>

<span class="sd">    Labels need not be unique but must be any hashable type. The object</span>
<span class="sd">    supports both integer- and label-based indexing and provides a host of</span>
<span class="sd">    methods for performing operations involving the index. Statistical</span>
<span class="sd">    methods from ndarray have been overridden to automatically exclude</span>
<span class="sd">    missing data (currently represented as NaN)</span>

<span class="sd">    Operations between Series (+, -, /, *, **) align values based on their</span>
<span class="sd">    associated index values-- they need not be the same length. The result</span>
<span class="sd">    index will be the sorted union of the two indexes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like, dict, or scalar value</span>
<span class="sd">        Contains data stored in Series</span>
<span class="sd">    index : array-like or Index (1d)</span>
<span class="sd">        Values must be unique and hashable, same length as data. Index</span>
<span class="sd">        object (or other iterable of same length as data) Will default to</span>
<span class="sd">        np.arange(len(data)) if not provided. If both a dict and index</span>
<span class="sd">        sequence are used, the index will override the keys found in the</span>
<span class="sd">        dict.</span>
<span class="sd">    dtype : numpy.dtype or None</span>
<span class="sd">        If None, dtype will be inferred</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">        Copy input data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">_allow_index_ops</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_allow_datetime_index_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># disabling to invalidate datetime index ops (GH7206)</span>
        <span class="c"># return self.index.is_all_dates and isinstance(self.index, DatetimeIndex)</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_allow_period_index_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># disabling to invalidate period index ops (GH7206)</span>
        <span class="c"># return self.index.is_all_dates and isinstance(self.index, PeriodIndex)</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="c"># we are called internally, so short-circuit</span>
        <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>

            <span class="c"># data is an ndarray, index is defined</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="c"># need to copy to avoid aliasing issues</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_to_embed</span><span class="p">(</span><span class="n">keep_tz</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">_try_sort</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
                        <span class="c"># coerce back to datetime objects for lookup</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">fast_multiget</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;O&#39;</span><span class="p">),</span>
                                                 <span class="n">default</span><span class="o">=</span><span class="n">pa</span><span class="o">.</span><span class="n">NA</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">fast_multiget</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                 <span class="n">default</span><span class="o">=</span><span class="n">pa</span><span class="o">.</span><span class="n">NA</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Categorical</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;{0!r} type is unordered&quot;</span>
                                <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># handle sparse passed here (and force conversion)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">_default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

            <span class="c"># create/copy the manager</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span>
                                       <span class="n">raise_cast_failure</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">generic</span><span class="o">.</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">fastpath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># return a sparse series here</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.sparse.series</span> <span class="kn">import</span> <span class="n">SparseSeries</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="n">SparseSeries</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="n">fastpath</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Series</span>

    <span class="c"># types</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_can_hold_na</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">_can_hold_na</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_time_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtyp</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;time_series&#39;</span><span class="p">,</span> <span class="s">&#39;sparse_time_series&#39;</span><span class="p">]</span>

    <span class="n">_index</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; override generic, we want to set the _typ here &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">is_all_dates</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">is_all_dates</span>
        <span class="k">if</span> <span class="n">is_all_dates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.period</span> <span class="kn">import</span> <span class="n">PeriodIndex</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="p">(</span><span class="n">DatetimeIndex</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">)):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

                <span class="c"># need to set here becuase we changed the index</span>
                <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_subtyp</span><span class="p">(</span><span class="n">is_all_dates</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_index&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_subtyp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_all_dates</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_all_dates</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s">&#39;time_series&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s">&#39;series&#39;</span><span class="p">)</span>

    <span class="c"># ndarray compatibility</span>
    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">strides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; for compat &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ftype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; for compat &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ftype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">base</span>

    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># 1-d compat with numpy</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; support for compatiblity &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; numpy like, returns same as nonzero &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
                                 <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the array interface, return my values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called after a ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called prior to a ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c"># complex</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">real</span>

    <span class="nd">@real.setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">imag</span>

    <span class="nd">@imag.setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">v</span>

    <span class="c"># coercion</span>
    <span class="n">__float__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">__long__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">__int__</span> <span class="o">=</span> <span class="n">_coerce_method</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c"># we are preserving name here</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpickle_series_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&#39;_data&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">index</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

            <span class="c"># &lt; 0.12 series pickle</span>

            <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>

            <span class="c"># recreate the ndarray</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nd_state</span><span class="p">)</span>

            <span class="c"># backwards compat</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">own_state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">own_state</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">own_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># recreate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">SingleBlockManager</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;cannot unpickle legacy formats -&gt; [</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="n">state</span><span class="p">)</span>

    <span class="c"># indexers</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_ixs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the i-th value or values in the Series by location</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, slice, or sequence of integers</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : scalar (int) or Series (slice, sequence)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_index</span><span class="o">.</span><span class="n">get_value_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s">&#39;iloc&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_index</span><span class="o">.</span><span class="n">get_value_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">slobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">typ</span> <span class="ow">or</span> <span class="s">&#39;getitem&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">slobj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>

                    <span class="c"># we need to box if we have a non-unique index here</span>
                    <span class="c"># otherwise have inline ndarray/lists</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>
                                                   <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                                                   <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>
        <span class="k">except</span> <span class="n">InvalidIndexError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c"># kludge</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="n">_is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># we can try to coerce the indexer (or this will raise)</span>
                <span class="n">new_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_scalar_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_with</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c"># other: fancy integer or otherwise</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s">&#39;getitem&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values_tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">raise</span>

            <span class="c"># pragma: no cover</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">inferred_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&#39;integer&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_floating</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&#39;boolean&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c"># handle the dup indexing case (GH 4246)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c"># [slice(0, 5, None)] will break if you convert to ndarray,</span>
                    <span class="c"># e.g. as requested by np.median</span>
                    <span class="c"># hack</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_get_values_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c"># mpl hackaround</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_values</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Can only tuple-index with a MultiIndex&#39;</span><span class="p">)</span>

        <span class="c"># If key is contained, would have returned by now</span>
        <span class="n">indexer</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span>
                                     <span class="n">fastpath</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_with_engine</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">SettingWithCopyError</span><span class="p">):</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s">&#39;integer&#39;</span><span class="p">):</span>

                <span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">_is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c"># reassign a null value to iNaT</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">iNaT</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
                        <span class="k">pass</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                                         <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Can only tuple-index with a MultiIndex&quot;</span><span class="p">)</span>

            <span class="c"># python 3 type errors should be raised</span>
            <span class="k">if</span> <span class="s">&#39;unorderable&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">InvalidIndexError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_with</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_with_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_set_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># other: fancy integer or otherwise</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="s">&#39;getitem&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">inferred_type</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key_type</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&#39;integer&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s">&#39;integer&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&#39;boolean&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> not contained in the index&#39;</span>
                             <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_values</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">setitem</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">()</span>

    <span class="c"># help out SparseSeries</span>
    <span class="n">_get_val_at</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">__getitem__</span>

    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See ndarray.repeat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See numpy.ndarray.reshape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c"># XXX ignoring the &quot;order&quot; keyword.</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">iget_value</span> <span class="o">=</span> <span class="n">_ixs</span>
    <span class="n">iget</span> <span class="o">=</span> <span class="n">_ixs</span>
    <span class="n">irow</span> <span class="o">=</span> <span class="n">_ixs</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly retrieve single value at passed index label</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : label</span>
<span class="sd">        takeable : interpret the index as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : scalar value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">takeable</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly set single value at passed label. If label is not contained, a</span>
<span class="sd">        new object is created with the label placed at the end of the result</span>
<span class="sd">        index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            Partial indexing with MultiIndex not allowed</span>
<span class="sd">        value : object</span>
<span class="sd">            Scalar value</span>
<span class="sd">        takeable : interpret the index as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        series : Series</span>
<span class="sd">            If label is contained, will be reference to calling Series,</span>
<span class="sd">            otherwise a new object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

            <span class="c"># set using a non-recursive method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogous to the :meth:`pandas.DataFrame.reset_index` function, see</span>
<span class="sd">        docstring there.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, tuple, or list, default None</span>
<span class="sd">            Only remove the given levels from the index. Removes all levels by</span>
<span class="sd">            default</span>
<span class="sd">        drop : boolean, default False</span>
<span class="sd">            Do not try to insert index into dataframe columns</span>
<span class="sd">        name : object, default None</span>
<span class="sd">            The name of the column corresponding to the Series values</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Modify the Series in place (do not create a new object)</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        resetted : DataFrame, or Series if drop == True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                    <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>
                <span class="c"># set name if it was passed, otherwise, keep the previous name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                         <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Cannot reset_index inplace on a Series &#39;</span>
                            <span class="s">&#39;to create a DataFrame&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="n">drop</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for a particular DataFrame</span>

<span class="sd">        Invoked by unicode(df) in py2 only. Yields a Unicode String in both</span>
<span class="sd">        py2/py3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">get_terminal_size</span><span class="p">()</span>
        <span class="n">max_rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s">&quot;display.max_rows&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">else</span> <span class="n">get_option</span><span class="p">(</span><span class="s">&quot;display.max_rows&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_rows</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_rows</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tidy_repr</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">max_rows</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_repr</span><span class="p">(</span><span class="n">print_header</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;Series([], dtype: </span><span class="si">%s</span><span class="s">)&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;Series([], name: </span><span class="si">%s</span><span class="s">, dtype: </span><span class="si">%s</span><span class="s">)&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_tidy_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_vals</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Internal function, should always return unicode string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_vals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">max_vals</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">max_vals</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">_get_repr</span><span class="p">(</span><span class="n">print_header</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">dtype</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">max_vals</span> <span class="o">-</span> <span class="n">num</span><span class="p">):]</span><span class="o">.</span><span class="n">_get_repr</span><span class="p">(</span><span class="n">print_header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                       <span class="n">length</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                       <span class="n">name</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                       <span class="n">dtype</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">...</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="n">tail</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_footer</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_footer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c"># time series</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_time_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;Freq: </span><span class="si">%s</span><span class="s">, &#39;</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freqstr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

            <span class="n">namestr</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&quot;Name: </span><span class="si">%s</span><span class="s">, &quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">com</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s%s</span><span class="s">Length: </span><span class="si">%d</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">freqstr</span><span class="p">,</span> <span class="n">namestr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c"># reg series</span>
        <span class="n">namestr</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s">&quot;Name: </span><span class="si">%s</span><span class="s">, &quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">com</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">Length: </span><span class="si">%d</span><span class="s">, dtype: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">namestr</span><span class="p">,</span>
                                               <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s">&#39;NaN&#39;</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">length</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a string representation of the Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : StringIO-like, optional</span>
<span class="sd">            buffer to write to</span>
<span class="sd">        na_rep : string, optional</span>
<span class="sd">            string representation of NAN to use, default &#39;NaN&#39;</span>
<span class="sd">        float_format : one-parameter function, optional</span>
<span class="sd">            formatter function to apply to columns&#39; elements if they are floats</span>
<span class="sd">            default None</span>
<span class="sd">        length : boolean, default False</span>
<span class="sd">            Add the Series length</span>
<span class="sd">        dtype : boolean, default False</span>
<span class="sd">            Add the Series dtype</span>
<span class="sd">        name : boolean, default False</span>
<span class="sd">            Add the Series name (which may be None)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        formatted : string (if not buffer passed)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">the_repr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_repr</span><span class="p">(</span><span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                                  <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c"># catch contract violations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">the_repr</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;result must be of type unicode, type&quot;</span>
                                 <span class="s">&quot; of result is {0!r}&quot;</span>
                                 <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">the_repr</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">the_repr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">the_repr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">the_repr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_repr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">print_header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="s">&#39;NaN&#39;</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Internal function, should always return unicode string</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">SeriesFormatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">print_header</span><span class="p">,</span>
                                        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                        <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                                        <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">formatter</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

        <span class="c"># TODO: following check prob. not neces.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;result must be of type unicode, type&quot;</span>
                                 <span class="s">&quot; of result is {0!r}&quot;</span>
                                 <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lazily iterate over (index, value) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">iteritems</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># unbox reductions</span>

    <span class="nb">all</span> <span class="o">=</span> <span class="n">_unbox</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
    <span class="nb">any</span> <span class="o">=</span> <span class="n">_unbox</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">any</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Misc public methods</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;Alias for index&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series as ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arr : numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; same as values (but handles sparseness conversions); is a view &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert Series to a nested list &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to {label -&gt; value} dict</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value_dict : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : object, default None</span>
<span class="sd">            The passed name should substitute for the series name (if it has</span>
<span class="sd">            one).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_frame : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;block&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Series to SparseSeries</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kind : {&#39;block&#39;, &#39;integer&#39;}</span>
<span class="sd">        fill_value : float, defaults to NaN (missing)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sp : SparseSeries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sparse</span> <span class="kn">import</span> <span class="n">SparseSeries</span>
        <span class="k">return</span> <span class="n">SparseSeries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Statistics, overridden ndarray methods</span>

    <span class="c"># TODO: integrate bottleneck</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of non-NA/null observations in the Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="sd">            particular level, collapsing into a smaller Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nobs : int or Series (if level specified)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">notnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

            <span class="n">level_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">level_index</span><span class="p">)</span>\
                           <span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c"># call cython function</span>
            <span class="n">max_bin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_index</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_ensure_int64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">count_level_1d</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
                                        <span class="n">labels</span><span class="p">,</span> <span class="n">max_bin</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">level_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">notnull</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the mode(s) of the dataset.</span>

<span class="sd">        Empty if nothing occurs at least 2 times.  Always returns Series even</span>
<span class="sd">        if only one value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort : bool, default True</span>
<span class="sd">            If True, will lexicographically sort values, if False skips</span>
<span class="sd">            sorting. Result ordering when ``sort=False`` is not defined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        modes : Series (sorted)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: Add option for bins like value_counts()</span>
        <span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="n">mode</span>
        <span class="k">return</span> <span class="n">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series with duplicate values removed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        take_last : boolean, default False</span>
<span class="sd">            Take the last observed index in a group. Default first</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If True, performs operation inplace and returns None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deduplicated : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">duplicated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">take_last</span><span class="o">=</span><span class="n">take_last</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">duplicated</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series denoting duplicate values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        take_last : boolean, default False</span>
<span class="sd">            Take the last observed index in a group. Default first</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        duplicated : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">_ensure_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">duplicated</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="n">take_last</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">duplicated</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index of first occurrence of minimum of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : boolean, default True</span>
<span class="sd">            Exclude NA/null values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idxmin : Index of minimum of values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the Series version of ``ndarray.argmin``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.idxmin</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index of first occurrence of maximum of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : boolean, default True</span>
<span class="sd">            Exclude NA/null values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idxmax : Index of maximum of values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the Series version of ``ndarray.argmax``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.idxmax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c"># ndarray compat</span>
    <span class="n">argmin</span> <span class="o">=</span> <span class="n">idxmin</span>
    <span class="n">argmax</span> <span class="o">=</span> <span class="n">idxmax</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>
                                       <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return value at the given quantile, a la numpy.percentile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like, default 0.5 (50% quantile)</span>
<span class="sd">            0 &lt;= q &lt;= 1, the quantile(s) to compute</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        quantile : float or Series</span>
<span class="sd">            if ``q`` is an array, a Series will be returned where the</span>
<span class="sd">            index is ``q`` and the values are the quantiles.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.quantile(.5)</span>
<span class="sd">            2.5</span>
<span class="sd">        &gt;&gt;&gt; s.quantile([.25, .5, .75])</span>
<span class="sd">        0.25    1.75</span>
<span class="sd">        0.50    2.50</span>
<span class="sd">        0.75    3.25</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>

        <span class="k">def</span> <span class="nf">multi</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">qs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">qs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">([</span><span class="n">_quantile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">qs</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">qs</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">multi</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">multi</span><span class="p">(</span><span class="n">valid_values</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;pearson&#39;</span><span class="p">,</span>
             <span class="n">min_periods</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute correlation with `other` Series, excluding missing values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;}</span>
<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations needed to have a valid result</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        correlation : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;inner&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>
        <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute covariance with Series, excluding missing values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations needed to have a valid result</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        covariance : float</span>

<span class="sd">        Normalized by N-1 (unbiased estimator).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;inner&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>
        <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancov</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                             <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1st discrete difference of object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            Periods to shift for forming difference</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diffed : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">periods</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lag-1 autocorrelation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        autocorr : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication with DataFrame or inner-product with Series</span>
<span class="sd">        objects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or DataFrame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : scalar or Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;matrices are not aligned&#39;</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Dot product shape mismatch, </span><span class="si">%s</span><span class="s"> vs </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unsupported type: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

<span class="c">#------------------------------------------------------------------------------</span>
<span class="c"># Combination</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_append</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate two or more Series. The indexes must not overlap</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_append : Series or list/tuple of Series</span>
<span class="sd">        verify_integrity : boolean, default False</span>
<span class="sd">            If True, raise Exception on creating index with duplicates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        appended : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tools.merge</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_append</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="n">to_append</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_append</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">verify_integrity</span><span class="o">=</span><span class="n">verify_integrity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform generic binary operation with optional fill value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        func : binary operator</span>
<span class="sd">        fill_value : float or object</span>
<span class="sd">            Value to substitute for NA/null values. If both Series are NA in a</span>
<span class="sd">            location, the result will be NA regardless of the passed fill value</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            Broadcast across a level, matching Index values on the</span>
<span class="sd">            passed MultiIndex level</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;Other operand must be Series&#39;</span><span class="p">)</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s">&#39;outer&#39;</span><span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>

        <span class="n">this_vals</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">values</span>
        <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">this_mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">this_vals</span><span class="p">)</span>
            <span class="n">other_mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">other_vals</span><span class="p">)</span>
            <span class="n">this_vals</span> <span class="o">=</span> <span class="n">this_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">other_vals</span> <span class="o">=</span> <span class="n">other_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c"># one but not both</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">this_mask</span> <span class="o">^</span> <span class="n">other_mask</span>
            <span class="n">this_vals</span><span class="p">[</span><span class="n">this_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
            <span class="n">other_vals</span><span class="p">[</span><span class="n">other_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">this_vals</span><span class="p">,</span> <span class="n">other_vals</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_maybe_match_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform elementwise binary operation on two Series using given function</span>
<span class="sd">        with optional fill value when an index is missing from one Series or</span>
<span class="sd">        the other</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series or scalar value</span>
<span class="sd">        func : function</span>
<span class="sd">        fill_value : scalar value</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">_maybe_match_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_index</span><span class="p">):</span>
                <span class="n">lv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">new_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine Series values, choosing the calling Series&#39;s values</span>
<span class="sd">        first. Result index will be the union of the two indexes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_maybe_match_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">rs_vals</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_where_compat</span><span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">this</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rs_vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify Series in place using non-NA values from passed</span>
<span class="sd">        Series. Aligns on index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notnull</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">()</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Reindexing, sorting</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels (along an axis)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ascending : boolean or list, default True</span>
<span class="sd">            Sort ascending vs. descending. Specify list for multiple sort</span>
<span class="sd">            orders</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; result1 = s.sort_index(ascending=False)</span>
<span class="sd">        &gt;&gt;&gt; result2 = s.sort_index(ascending=[1, 0])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_obj : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="kn">import</span> <span class="n">_lexsort_indexer</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">_lexsort_indexer</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
            <span class="n">new_labels</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_labels</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">return_indexer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                              <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_labels</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides ndarray.argsort. Argsorts the value, omitting NA/null values,</span>
<span class="sd">        and places the result in the same locations as the non-NA values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int (can only be zero)</span>
<span class="sd">        kind : {&#39;mergesort&#39;, &#39;quicksort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See np.sort for more</span>
<span class="sd">            information. &#39;mergesort&#39; is the only stable algorithm</span>
<span class="sd">        order : ignored</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        argsorted : Series, with -1 indicated where nan values are present</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
            <span class="n">notmask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
            <span class="n">result</span><span class="p">[</span><span class="n">notmask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">notmask</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;average&#39;</span><span class="p">,</span> <span class="n">na_option</span><span class="o">=</span><span class="s">&#39;keep&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">pct</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute data ranks (1 through n). Equal values are assigned a rank that</span>
<span class="sd">        is the average of the ranks of those values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}</span>
<span class="sd">            * average: average rank of group</span>
<span class="sd">            * min: lowest rank in group</span>
<span class="sd">            * max: highest rank in group</span>
<span class="sd">            * first: ranks assigned in order they appear in the array</span>
<span class="sd">            * dense: like &#39;min&#39;, but rank always increases by 1 between groups</span>
<span class="sd">        na_option : {&#39;keep&#39;}</span>
<span class="sd">            keep: leave NA values where they are</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            False for ranks by high (1) to low (N)</span>
<span class="sd">        pct : boolean, default False</span>
<span class="sd">            Computes percentage rank of data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranks : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.algorithms</span> <span class="kn">import</span> <span class="n">rank</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
                     <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s">&#39;last&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort values and index labels by value. This is an inplace sort by default.</span>
<span class="sd">        Series.order is the equivalent but returns a new Series.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int (can only be zero)</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            Sort ascending. Passing False sorts descending</span>
<span class="sd">        kind : {&#39;mergesort&#39;, &#39;quicksort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See np.sort for more</span>
<span class="sd">            information. &#39;mergesort&#39; is the only stable algorithm</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;} (optional, default=&#39;last&#39;)</span>
<span class="sd">            &#39;first&#39; puts NaNs at the beginning</span>
<span class="sd">            &#39;last&#39; puts NaNs at the end</span>
<span class="sd">        inplace : boolean, default True</span>
<span class="sd">            Do operation in place.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                          <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                          <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span>
                          <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_last</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s">&#39;last&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts Series object, by value, maintaining index-value link.</span>
<span class="sd">        This will return a new Series by default. Series.sort is the equivalent but as an inplace method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na_last : boolean (optional, default=True) (DEPRECATED; use na_position)</span>
<span class="sd">            Put NaN&#39;s at beginning or end</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            Sort ascending. Passing False sorts descending</span>
<span class="sd">        kind : {&#39;mergesort&#39;, &#39;quicksort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See np.sort for more</span>
<span class="sd">            information. &#39;mergesort&#39; is the only stable algorithm</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;} (optional, default=&#39;last&#39;)</span>
<span class="sd">            &#39;first&#39; puts NaNs at the beginning</span>
<span class="sd">            &#39;last&#39; puts NaNs at the end</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Do operation in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># GH 5856/5853</span>
        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;This Series is a view of some other array, to &quot;</span>
                             <span class="s">&quot;sort in-place you must create a copy&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">na_last</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s">&quot;na_last is deprecated. Please use na_position instead&quot;</span><span class="p">),</span>
                          <span class="ne">FutureWarning</span><span class="p">)</span>
            <span class="n">na_position</span> <span class="o">=</span> <span class="s">&#39;last&#39;</span> <span class="k">if</span> <span class="n">na_last</span> <span class="k">else</span> <span class="s">&#39;first&#39;</span>

        <span class="k">def</span> <span class="nf">_try_kind_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c"># easier to ask forgiveness than permission</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># if kind==mergesort, it can fail for object dtype</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c"># stable sort not available for object dtype</span>
                <span class="c"># uses the argsort default quicksort</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s">&#39;quicksort&#39;</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">sortedIdx</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">bad</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

        <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">argsorted</span> <span class="o">=</span> <span class="n">_try_kind_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">good</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">argsorted</span> <span class="o">=</span> <span class="n">argsorted</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">na_position</span> <span class="o">==</span> <span class="s">&#39;last&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">good</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sortedIdx</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">good</span><span class="p">][</span><span class="n">argsorted</span><span class="p">]</span>
            <span class="n">sortedIdx</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">na_position</span> <span class="o">==</span> <span class="s">&#39;first&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">bad</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sortedIdx</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">good</span><span class="p">][</span><span class="n">argsorted</span><span class="p">]</span>
            <span class="n">sortedIdx</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">bad</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;invalid na_position: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">na_position</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">sortedIdx</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">sortedIdx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the largest `n` elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Return this many descending sorted values</span>
<span class="sd">        take_last : bool</span>
<span class="sd">            Where there are duplicate values, take the last duplicate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        top_n : Series</span>
<span class="sd">            The n largest values in the Series, in sorted order</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Faster than ``.order(ascending=False).head(n)`` for small `n` relative</span>
<span class="sd">        to the size of the ``Series`` object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nsmallest</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.random.randn(1e6))</span>
<span class="sd">        &gt;&gt;&gt; s.nlargest(10)  # only sorts up to the N requested</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="n">take_last</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;nlargest&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the smallest `n` elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Return this many ascending sorted values</span>
<span class="sd">        take_last : bool</span>
<span class="sd">            Where there are duplicate values, take the last duplicate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bottom_n : Series</span>
<span class="sd">            The n smallest values in the Series, in sorted order</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Faster than ``.order().head(n)`` for small `n` relative to</span>
<span class="sd">        the size of the ``Series`` object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nlargest</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.random.randn(1e6))</span>
<span class="sd">        &gt;&gt;&gt; s.nsmallest(10)  # only sorts up to the N requested</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">select_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">take_last</span><span class="o">=</span><span class="n">take_last</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;nsmallest&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort Series with MultiIndex by chosen level. Data will be</span>
<span class="sd">        lexicographically sorted by the chosen level followed by the other</span>
<span class="sd">        levels (in order)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">        ascending : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;can only sort by level with a hierarchical index&#39;</span><span class="p">)</span>

        <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">sortlevel</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                                                 <span class="n">sort_remaining</span><span class="o">=</span><span class="n">sort_remaining</span><span class="p">)</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int, string (can be mixed)</span>
<span class="sd">            Level of index to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rearrange index levels using input order. May not drop or duplicate</span>
<span class="sd">        levels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order: list of int representing new level order.</span>
<span class="sd">               (reference level by number or key)</span>
<span class="sd">        axis: where to reorder levels</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type of caller (new object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Can only reorder levels on a hierarchical axis.&#39;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, string, or list of these, default last level</span>
<span class="sd">            Level(s) to unstack, can pass level name</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        one  a   1.</span>
<span class="sd">        one  b   2.</span>
<span class="sd">        two  a   3.</span>
<span class="sd">        two  b   4.</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=-1)</span>
<span class="sd">             a   b</span>
<span class="sd">        one  1.  2.</span>
<span class="sd">        two  3.  4.</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=0)</span>
<span class="sd">           one  two</span>
<span class="sd">        a  1.   2.</span>
<span class="sd">        b  3.   4.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unstacked : DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape</span> <span class="kn">import</span> <span class="n">unstack</span>
        <span class="k">return</span> <span class="n">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># function application</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">na_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map values of Series using input correspondence (which can be</span>
<span class="sd">        a dict, Series, or function)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg : function, dict, or Series</span>
<span class="sd">        na_action : {None, &#39;ignore&#39;}</span>
<span class="sd">            If &#39;ignore&#39;, propagate NA values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        one   1</span>
<span class="sd">        two   2</span>
<span class="sd">        three 3</span>

<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        1  foo</span>
<span class="sd">        2  bar</span>
<span class="sd">        3  baz</span>

<span class="sd">        &gt;&gt;&gt; x.map(y)</span>
<span class="sd">        one   foo</span>
<span class="sd">        two   bar</span>
<span class="sd">        three baz</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>
<span class="sd">            same index as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">na_action</span> <span class="o">==</span> <span class="s">&#39;ignore&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">map_f</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer_mask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_f</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">arg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">take_1d</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapped</span> <span class="o">=</span> <span class="n">map_f</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">convert_dtype</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke function on values of Series. Can be ufunc (a NumPy function</span>
<span class="sd">        that applies to the entire Series) or a Python function that only works</span>
<span class="sd">        on single values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">        convert_dtype : boolean, default True</span>
<span class="sd">            Try to find better dtype for elementwise function results. If</span>
<span class="sd">            False, leave as dtype=object</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments to pass to function in addition to the value</span>
<span class="sd">        Additional keyword arguments will be passed as keywords to the function</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.map: For element-wise operations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series or DataFrame if func returns a Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kwds</span> <span class="ow">or</span> <span class="n">args</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ufunc</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)</span>

        <span class="n">mapped</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapped</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">mapped</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">filter_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; perform a reduction operation &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c"># be subclass-friendly</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">take_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(),</span> <span class="n">indexer</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check if we do need a multi reindex; this is for compat with</span>
<span class="sd">        higher dims</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;rename&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; for compatibility with higher dims &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot reindex series on non-zero axis!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogous to ndarray.take, return Series corresponding to requested</span>
<span class="sd">        indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : list / array of ints</span>
<span class="sd">        convert : translate negative to positive indices (default)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        taken : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check/convert indicies here</span>
        <span class="k">if</span> <span class="n">convert</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">_maybe_convert_indices</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)))</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean :class:`~pandas.Series` showing whether each element</span>
<span class="sd">        in the :class:`~pandas.Series` is exactly contained in the passed</span>
<span class="sd">        sequence of ``values``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : list-like</span>
<span class="sd">            The sequence of values to test. Passing in a single string will</span>
<span class="sd">            raise a ``TypeError``. Instead, turn a single string into a</span>
<span class="sd">            ``list`` of one element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        isin : Series (bool dtype)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">          * If ``values`` is a string</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.isin</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(list(&#39;abc&#39;))</span>
<span class="sd">        &gt;&gt;&gt; s.isin([&#39;a&#39;, &#39;c&#39;, &#39;e&#39;])</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2     True</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        Passing a single string as ``s.isin(&#39;a&#39;)`` will raise an error. Use</span>
<span class="sd">        a list of one element instead:</span>

<span class="sd">        &gt;&gt;&gt; s.isin([&#39;a&#39;])</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;only list-like objects are allowed to be passed&quot;</span>
                            <span class="s">&quot; to Series.isin(), you passed a &quot;</span>
                            <span class="s">&quot;{0!r}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="c"># may need i8 conversion for proper membership testing</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.tools</span> <span class="kn">import</span> <span class="n">to_datetime</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="n">comps</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">com</span><span class="o">.</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.timedeltas</span> <span class="kn">import</span> <span class="n">to_timedelta</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="n">comps</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>

        <span class="n">value_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">ismember</span><span class="p">(</span><span class="n">comps</span><span class="p">,</span> <span class="n">value_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series equivalent to left &lt;= series &lt;= right. NA values</span>
<span class="sd">        will be treated as False</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : scalar</span>
<span class="sd">            Left boundary</span>
<span class="sd">        right : scalar</span>
<span class="sd">            Right boundary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_between : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inclusive</span><span class="p">:</span>
            <span class="n">lmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">left</span>
            <span class="n">rmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&gt;</span> <span class="n">left</span>
            <span class="n">rmask</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">right</span>

        <span class="k">return</span> <span class="n">lmask</span> <span class="o">&amp;</span> <span class="n">rmask</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read delimited file into Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string file path or file handle / StringIO</span>
<span class="sd">        sep : string, default &#39;,&#39;</span>
<span class="sd">            Field delimiter</span>
<span class="sd">        parse_dates : boolean, default True</span>
<span class="sd">            Parse dates. Different default from read_table</span>
<span class="sd">        header : int, default 0</span>
<span class="sd">            Row to use at header (skip prior rows)</span>
<span class="sd">        index_col : int or sequence, default 0</span>
<span class="sd">            Column to use for index. If a sequence is given, a MultiIndex</span>
<span class="sd">            is used. Different default from read_table</span>
<span class="sd">        encoding : string, optional</span>
<span class="sd">            a string representing the encoding to use if the contents are</span>
<span class="sd">            non-ascii, for python versions prior to 3</span>
<span class="sd">        infer_datetime_format: boolean, default False</span>
<span class="sd">            If True and `parse_dates` is True for a column, try to infer the</span>
<span class="sd">            datetime format based on the first datetime string. If the format</span>
<span class="sd">            can be inferred, there often will be a large parsing speed-up.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="n">index_col</span><span class="p">,</span>
                                <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="n">parse_dates</span><span class="p">,</span>
                                <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                                <span class="n">infer_datetime_format</span><span class="o">=</span><span class="n">infer_datetime_format</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">icol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span>
               <span class="n">float_format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">index_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">nanRep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">date_format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write Series to a comma-separated values (csv) file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string file path or file handle / StringIO</span>
<span class="sd">        na_rep : string, default &#39;&#39;</span>
<span class="sd">            Missing data representation</span>
<span class="sd">        float_format : string, default None</span>
<span class="sd">            Format string for floating point numbers</span>
<span class="sd">        header : boolean, default False</span>
<span class="sd">            Write out series name</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Write row names (index)</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s) if desired. If None is given, and</span>
<span class="sd">            `header` and `index` are True, then the index names are used. A</span>
<span class="sd">            sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        mode : Python write mode, default &#39;w&#39;</span>
<span class="sd">        sep : character, default &quot;,&quot;</span>
<span class="sd">            Field delimiter for the output file.</span>
<span class="sd">        encoding : string, optional</span>
<span class="sd">            a string representing the encoding to use if the contents are</span>
<span class="sd">            non-ascii, for python versions prior to 3</span>
<span class="sd">        date_format: string, default None</span>
<span class="sd">            Format string for datetime objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                  <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                  <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">nanRep</span><span class="o">=</span><span class="n">nanRep</span><span class="p">,</span>
                  <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Series without null values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid : Series</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Do operation in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">remove_na</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="n">valid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">first_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return label for first non-NA/null value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return label for last non-NA/null value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c">#----------------------------------------------------------------------</span>
    <span class="c"># Time series-oriented methods</span>

    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return last good (non-NaN) value in TimeSeries if value is NaN for</span>
<span class="sd">        requested date.</span>

<span class="sd">        If there is no good value, NaN is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : date or array of dates</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dates are assumed to be sorted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value or NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">datetools</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">Period</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">ordinal</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">ordinal</span>

            <span class="k">if</span> <span class="n">where</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pa</span><span class="o">.</span><span class="n">NA</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">])</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">asof_locs</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">notnull</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">take_1d</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.strings</span> <span class="kn">import</span> <span class="n">StringMethods</span>
        <span class="k">return</span> <span class="n">StringMethods</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s">&#39;start&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to datetimeindex of timestamps, at *beginning* of period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : string, default frequency of PeriodIndex</span>
<span class="sd">            Desired frequency</span>
<span class="sd">        how : {&#39;s&#39;, &#39;e&#39;, &#39;start&#39;, &#39;end&#39;}</span>
<span class="sd">            Convention for converting period to timestamp; start of period</span>
<span class="sd">            vs. end</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : TimeSeries with DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert TimeSeries from DatetimeIndex to PeriodIndex with desired</span>
<span class="sd">        frequency (inferred from index if not passed)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : string, default</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : TimeSeries with PeriodIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="n">Series</span><span class="o">.</span><span class="n">_setup_axes</span><span class="p">([</span><span class="s">&#39;index&#39;</span><span class="p">],</span> <span class="n">info_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stat_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">aliases</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;rows&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="n">Series</span><span class="o">.</span><span class="n">_add_numeric_operations</span><span class="p">()</span>
<span class="n">_INDEX_TYPES</span> <span class="o">=</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span>

<span class="c">#------------------------------------------------------------------------------</span>
<span class="c"># Supplementary functions</span>


<span class="k">def</span> <span class="nf">remove_na</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return series containing only true/non-NaN values, possibly empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">series</span><span class="p">[</span><span class="n">notnull</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="n">series</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">_sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">raise_cast_failure</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_maybe_upcast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_try_cast</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">take_fast_path</span><span class="p">):</span>

        <span class="c"># perf shortcut as this is the most common case</span>
        <span class="k">if</span> <span class="n">take_fast_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_possibly_castable</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">_possibly_cast_to_datetime</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">raise_cast_failure</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subarr</span>

    <span class="c"># GH #846</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

            <span class="c"># possibility of nan -&gt; garbage</span>
            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_float_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">com</span><span class="o">.</span><span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="n">com</span><span class="o">.</span><span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                        <span class="n">ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;i8&#39;</span><span class="p">)</span>
                        <span class="n">subarr</span> <span class="o">=</span> <span class="n">tslib</span><span class="o">.</span><span class="n">ints_to_pydatetime</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">raise_cast_failure</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Cannot cast datetime64 to </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># don&#39;t coerce Index types</span>
            <span class="c"># e.g. indexes can have different conversions (so don&#39;t fast path them)</span>
            <span class="c"># GH 6140</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Index</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_cast_failure</span><span class="p">:</span>  <span class="c"># pragma: no cover</span>
                    <span class="k">raise</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_possibly_convert_platform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">subarr</span> <span class="o">=</span> <span class="n">_possibly_cast_to_datetime</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">_try_cast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="c"># scalar like</span>
    <span class="k">if</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>  <span class="c"># pragma: no cover</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c"># figure out the dtype from the value (upcast if necessary)</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">_infer_dtype_from_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># need to possibly convert the value here</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_possibly_cast_to_datetime</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

            <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">subarr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subarr</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="c"># the result that we want</span>
    <span class="k">elif</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

            <span class="c"># a 1-element ndarray</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">subarr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">subarr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">subarr</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">subarr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Data must be 1-dimensional&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c"># This is to prevent mixed-type Series getting all casted to</span>
    <span class="c"># NumPy string type, e.g. NaN --&gt; &#39;-1#IND&#39;.</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">subarr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subarr</span>

<span class="c"># backwards compatiblity</span>
<span class="n">TimeSeries</span> <span class="o">=</span> <span class="n">Series</span>

<span class="c">#----------------------------------------------------------------------</span>
<span class="c"># Add plotting methods to Series</span>

<span class="kn">import</span> <span class="nn">pandas.tools.plotting</span> <span class="kn">as</span> <span class="nn">_gfx</span>

<span class="n">Series</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">_gfx</span><span class="o">.</span><span class="n">plot_series</span>
<span class="n">Series</span><span class="o">.</span><span class="n">hist</span> <span class="o">=</span> <span class="n">_gfx</span><span class="o">.</span><span class="n">hist_series</span>

<span class="c"># Add arithmetic!</span>
<span class="n">ops</span><span class="o">.</span><span class="n">add_flex_arithmetic_methods</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="o">**</span><span class="n">ops</span><span class="o">.</span><span class="n">series_flex_funcs</span><span class="p">)</span>
<span class="n">ops</span><span class="o">.</span><span class="n">add_special_arithmetic_methods</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="o">**</span><span class="n">ops</span><span class="o">.</span><span class="n">series_special_funcs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorial/installation_dependencies.html">Dependencies/Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorial/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorial/plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../API/skspec.html">API</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
            <p class="searchtip" style="font-size: 90%">
                Enter search terms or a module, class or function name.
            </p>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../../../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../../../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Adam Hughes, ReevesLab Dept. Physics, George Washington University.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>